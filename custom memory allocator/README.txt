This project implements a simple custom memory allocator (`cma`) that manages a fixed-size 1 MB heap using a linked list of free and allocated memory blocks. It supports dynamic allocation, deallocation, and reallocation with features such as block splitting and coalescing to optimize memory use and reduce fragmentation. The allocator also tracks detailed statistics including total allocated and freed bytes, current memory usage, and the number of allocation and free operations performed. A C++ STL-compatible allocator template (`cma_allocator`) wraps this custom allocator, allowing seamless integration with standard containers like `std::vector`. The demonstration in the `main()` function shows how to use `std::vector<int>` with the custom allocator, including printing memory block states and allocation statistics before and after modifications to the vector. This kind of custom allocator is particularly relevant in embedded systems and other resource-constrained environments where memory is limited and fragmentation needs to be minimized. Standard library allocators may not always be suitable or efficient in such contexts. Having fine-grained control over memory allocation and layout is important for ensuring predictable and reliable behavior, especially in real-time or safety-critical applications. This allocator demonstrates core techniques useful in embedded firmware development, including manual heap management, block splitting and merging, and compatibility with standard C++ containers for flexible data structures with controlled memory usage. Internally, the allocator reserves a contiguous 1 MB buffer aligned to accommodate any data type. It manages this buffer as a linked list of blocks, each containing metadata about size, free status, and a pointer to the next block. Allocation involves searching for a free block large enough to satisfy the request, splitting the block if it is significantly larger, and marking it as used. Deallocation marks a block as free and attempts to merge adjacent free blocks to minimize fragmentation. Reallocation either expands the existing block if possible or allocates new memory and copies the data. Throughout these operations, the allocator maintains internal statistics to help with debugging and profiling memory usage.
