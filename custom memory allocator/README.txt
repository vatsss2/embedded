This project implements a simple custom memory allocator (`cma`) that manages a fixed-size 1 MB heap using a linked list of free and allocated memory blocks. It supports dynamic allocation, deallocation, and reallocation with features such as block splitting and coalescing to optimize memory use and reduce fragmentation. The allocator also tracks detailed statistics including total allocated and freed bytes, current memory usage, and the number of allocation and free operations performed. A C++ STL-compatible allocator template (`cma_allocator`) wraps this custom allocator, allowing seamless integration with standard containers like `std::vector`. The demonstration in the `main()` function shows how to use `std::vector<int>` with the custom allocator, including printing memory block states and allocation statistics before and after modifications to the vector. This kind of custom allocator is particularly relevant in embedded systems and other resource-constrained environments where memory is limited and fragmentation needs to be minimized. Standard library allocators may not always be suitable or efficient in such contexts. Having fine-grained control over memory allocation and layout is important for ensuring predictable and reliable behavior, especially in real-time or safety-critical applications. This allocator demonstrates core techniques useful in embedded firmware development, including manual heap management, block splitting and merging, and compatibility with standard C++ containers for flexible data structures with controlled memory usage.
